# app_animal_behavior_2026.py
# ------------------------------------------------------------
# ç‰ˆæœ¬è®Šæ›´èªªæ˜ï¼ˆå¯å®Œå…¨è¦†è“‹ç‰ˆï¼‰
# 1) æ“´å¤§å„åˆ†é ã€ŒæŠ•ç¨¿é¡Œç›®ã€æ¬„ä½åµæ¸¬ç¯„åœï¼ˆé¡Œç›®/è¬›é¡Œ/Title/Topic...ï¼‰ã€‚
# 2) é¡Œç›®è·¨æ¬„æ‹¼æ¥ï¼šå¾é¡Œç›®æ¬„ä½èµ·ï¼Œå‘å³æœ€å¤šå†æ‹¼æ¥ TITLE_SPAN_RIGHT æ¬„ï¼ˆè™•ç†åˆä½µå„²å­˜æ ¼/è·¨æ¬„è¼¸å‡ºï¼‰ã€‚
# 3) row-level fallbackï¼šè‹¥ä»æŠ“ä¸åˆ° titleï¼Œå¾æ•´åˆ—æŒ‘æœ€åƒé¡Œç›®çš„é•·æ–‡å­—è£œä¸Šã€‚
# 4) æ–°å¢ã€Œæµ·å ±ã€åˆ†é è§£æï¼šå¯æœå°‹ä¸¦åŠ å…¥å€‹äººè¡Œäº‹æ›†ï¼Œä¸”è‡ªå‹•å¸¶å…¥ D1/D2 èˆ‡æµ·å ±è§£èªª/ç«¶è³½æ™‚é–“ã€‚
# 5) åŒ¯å‡º .icsï¼šSUMMARY é¡¯ç¤ºã€ŒPA01ï½œé¡Œç›®ã€ï¼ŒDESCRIPTION æ”¾ä¸»é¡Œé ˜åŸŸç­‰è³‡è¨Šï¼ˆå« RFC5545 è½‰ç¾©ï¼‰ã€‚
# 6) UI æ”¹ç‚ºä¸Šä¸‹æ’åˆ—ï¼š1) æœå°‹çµæœåœ¨ä¸Šï¼Œ2) å€‹äººè¡Œäº‹æ›†åœ¨ä¸‹ã€‚
# 7) ğŸ”” å·²é¸è¡Œç¨‹å…§éƒ¨è¡çªè‡ªå‹•æ¨™ç´…ï¼ˆåŒæ—¥æ™‚é–“é‡ç–Šï¼‰ï¼Œä½† **æµ·å ± (kind=poster) ä¸è¨ˆå…¥è¡çª**ã€‚
# 8) ğŸ“Š é¡¯ç¤º D1 / D2 å·²é¸æ•¸é‡èˆ‡è¡çªå ´æ¬¡æ•¸é‡ï¼ˆè¡çªä¸å«æµ·å ±ï¼‰ã€‚
# 9) ğŸ“± æ‰‹æ©Ÿå‹å–„ï¼šD1 / D2 è¡Œäº‹æ›†ç”¨ expander æŠ˜ç–Šã€‚
# 10) âœ… æœå°‹çµæœåˆ—è¡¨ä¹Ÿæœƒé¡¯ç¤ºã€Œâš ï¸ æœƒèˆ‡å·²é¸è¡Œç¨‹è¡çªã€æç¤ºï¼Œä½† **æµ·å ±ä¸é¡¯ç¤ºè¡çªâš ï¸**ã€‚
#
# Usage:
#   streamlit run app_animal_behavior_2026.py
#
# Author: generated by ChatGPT for Yuju

from __future__ import annotations

import re
import io
import datetime as dt
from typing import Dict, Tuple, Optional, List

import pandas as pd
import streamlit as st

APP_TITLE = "å‹•ç‰©è¡Œç‚ºç ”è¨æœƒ 2026ï½œè­°ç¨‹æœå°‹ï¼‹å€‹äººåŒ–è¡Œäº‹æ›†"
DEFAULT_EXCEL_PATH = "2026 å‹•è¡Œè­°ç¨‹.xlsx"

DATE_MAP = {
    "D1": dt.date(2026, 1, 26),
    "D2": dt.date(2026, 1, 27),
}

TITLE_SPAN_RIGHT = 6

# ----------------------------
# Parsing helpers
# ----------------------------

_TIME_RANGE_RE = re.compile(r"^(\d{1,2}:\d{2})\s*[-â€“~]\s*(\d{1,2}:\d{2})$")
_TIME_RANGE_IN_TEXT_RE = re.compile(r"(\d{1,2}:\d{2})\s*[-â€“~]\s*(\d{1,2}:\d{2})")


def _parse_time_str(s: str) -> Optional[dt.time]:
    if s is None:
        return None
    s = str(s).strip()
    if not s:
        return None
    s = s.replace("ï¼š", ":").replace("ï¼", ".")
    s = re.split(r"\s|\(|ï¼ˆ", s)[0].strip()

    m = re.fullmatch(r"(\d{1,2})(?::(\d{1,2}))?", s)
    if m:
        h = int(m.group(1))
        mi = int(m.group(2) or 0)
        if 0 <= h <= 23 and 0 <= mi <= 59:
            return dt.time(hour=h, minute=mi)

    m = re.fullmatch(r"(\d{1,2})\.(\d{1,2})", s)
    if m:
        h = int(m.group(1))
        mi = int(m.group(2))
        if 0 <= h <= 23 and 0 <= mi <= 59:
            return dt.time(hour=h, minute=mi)

    m = re.fullmatch(r"(\d{2})(\d{2})", s)
    if m:
        h = int(m.group(1))
        mi = int(m.group(2))
        if 0 <= h <= 23 and 0 <= mi <= 59:
            return dt.time(hour=h, minute=mi)

    m = re.fullmatch(r"(\d{1,2}):(\d{2})", s)
    if m:
        hh = int(m.group(1))
        mm = int(m.group(2))
        if 0 <= hh <= 23 and 0 <= mm <= 59:
            return dt.time(hour=hh, minute=mm)

    return None


def _parse_time_range(x: object) -> Optional[Tuple[str, str]]:
    if x is None or (isinstance(x, float) and pd.isna(x)) or (isinstance(x, pd._libs.missing.NAType)):  # type: ignore
        return None
    s = str(x).strip()
    m = _TIME_RANGE_RE.match(s)
    if not m:
        return None
    return m.group(1), m.group(2)


def _extract_time_range_from_text(s: object) -> Optional[Tuple[str, str]]:
    if s is None or (isinstance(s, float) and pd.isna(s)):
        return None
    txt = str(s)
    m = _TIME_RANGE_IN_TEXT_RE.search(txt)
    if not m:
        return None
    return m.group(1), m.group(2)


def _safe_str(x: object) -> Optional[str]:
    if x is None:
        return None
    if isinstance(x, float) and pd.isna(x):
        return None
    s = str(x).strip()
    if s == "" or s.lower() == "nan":
        return None
    return s


def _find_col(cols: List[str], candidates: List[str]) -> Optional[str]:
    for c in cols:
        if not isinstance(c, str):
            continue
        for cand in candidates:
            if cand in c:
                return c
    return None


def _join_nonempty(parts: List[Optional[str]], sep: str = " ") -> Optional[str]:
    xs = [p.strip() for p in parts if p and str(p).strip()]
    if not xs:
        return None
    s = sep.join(xs)
    s = re.sub(r"\s+", " ", s).strip()
    return s or None


def _extract_title_with_span(row: pd.Series, cols: List[str], base_col: Optional[str], span_right: int) -> Optional[str]:
    if not base_col or base_col not in row.index:
        return None
    try:
        i0 = cols.index(base_col)
    except ValueError:
        return _safe_str(row.get(base_col))

    parts: List[Optional[str]] = []
    for j in range(i0, min(len(cols), i0 + 1 + span_right)):
        v = _safe_str(row.get(cols[j]))
        cname = str(cols[j])
        if j != i0 and re.search(r"(å–®ä½|ä¸»æŒ|è¬›è€…|ä½œè€…|ç·¨è™Ÿ|æ™‚é–“|å ±å‘Šæ™‚é–“)", cname):
            continue
        parts.append(v)

    title = _join_nonempty(parts, sep=" ")
    if title in ("æŠ•ç¨¿é¡Œç›®", "æ¼”è¬›ä¸»é¡Œ", "ä¸»é¡Œé ˜åŸŸ", "é¡Œç›®", "è¬›é¡Œ"):
        return None
    return title


def _fallback_title_from_row(row: pd.Series) -> Optional[str]:
    best: Optional[str] = None
    best_score = -1
    for _, v in row.items():
        s = _safe_str(v)
        if not s:
            continue
        if _parse_time_range(s):
            continue
        if re.fullmatch(r"[A-Za-z]?\d{2,6}", s):
            continue
        if re.search(r"^D[12]$", s.strip()):
            continue
        if len(s) < 8:
            continue

        score = len(s)
        if re.search(r"[\u4e00-\u9fff]", s):
            score += 10
        if " " in s:
            score += 3
        if score > best_score:
            best = s
            best_score = score
    return best


@st.cache_data(show_spinner=False)
def load_excel_all_sheets(file_bytes: bytes) -> Dict[str, pd.DataFrame]:
    xl = pd.ExcelFile(io.BytesIO(file_bytes))
    return {name: pd.read_excel(io.BytesIO(file_bytes), sheet_name=name) for name in xl.sheet_names}


@st.cache_data(show_spinner=False)
def build_master_df(sheets: Dict[str, pd.DataFrame]) -> pd.DataFrame:
    master: List[Dict[str, object]] = []

    if "å¤§æœƒè­°ç¨‹" in sheets:
        df = sheets["å¤§æœƒè­°ç¨‹"].copy()
        cur_day: Optional[str] = None

        for _, row in df.iterrows():
            first = row.iloc[0]
            if isinstance(first, str) and first.strip() in ("D1", "D2"):
                cur_day = first.strip()
                continue

            tr = _parse_time_range(first) if isinstance(first, str) else None
            if not (tr and cur_day):
                continue

            start, end = tr
            t_start = _parse_time_str(start)
            t_end = _parse_time_str(end)
            if t_start is None or t_end is None:
                continue

            for col in df.columns[1:]:
                val = row[col]
                title = _safe_str(val)
                if not title:
                    continue
                if "è«‹é»æˆ‘" in title:
                    continue

                room = str(col).strip()
                master.append(
                    dict(
                        source_sheet="å¤§æœƒè­°ç¨‹",
                        day=cur_day,
                        date=DATE_MAP[cur_day].isoformat(),
                        room=room,
                        location=room,
                        code=None,
                        session=None,
                        title=title,
                        speaker=None,
                        affiliation=None,
                        start=start,
                        end=end,
                        start_dt=dt.datetime.combine(DATE_MAP[cur_day], t_start),
                        end_dt=dt.datetime.combine(DATE_MAP[cur_day], t_end),
                        kind="main_schedule",
                    )
                )

    for sheet_name, df0 in sheets.items():
        if sheet_name == "å¤§æœƒè­°ç¨‹":
            continue

        # ---- æµ·å ± ----
        if str(sheet_name).strip() == "æµ·å ±":
            dfp = df0.copy()
            cols_p = [str(c) for c in dfp.columns]

            col_code_p = cols_p[0] if len(cols_p) >= 1 else None
            col_author_p = cols_p[1] if len(cols_p) >= 2 else None
            col_title_p = cols_p[2] if len(cols_p) >= 3 else None
            col_area_p = cols_p[3] if len(cols_p) >= 4 else None

            cur_day: Optional[str] = None
            poster_session_tr: Optional[Tuple[str, str]] = None

            for _, rowp in dfp.iterrows():
                v0 = _safe_str(rowp.get(col_code_p)) if col_code_p else None

                if v0 and "Day 1" in v0:
                    cur_day = "D1"
                    poster_session_tr = None
                    continue
                if v0 and "Day 2" in v0:
                    cur_day = "D2"
                    poster_session_tr = None
                    continue

                if v0 and ("æµ·å ±ç«¶è³½æ™‚é–“" in v0 or "æµ·å ±è§£èªªæ™‚é–“" in v0):
                    poster_session_tr = _extract_time_range_from_text(v0)
                    continue

                if not (v0 and re.fullmatch(r"P[A-Z]\d{2}", v0.strip())):
                    continue
                if not cur_day or cur_day not in DATE_MAP:
                    continue
                if not poster_session_tr:
                    continue

                start, end = poster_session_tr
                t_start = _parse_time_str(start)
                t_end = _parse_time_str(end)
                if t_start is None or t_end is None:
                    continue

                author = _safe_str(rowp.get(col_author_p)) if col_author_p else None
                title = _safe_str(rowp.get(col_title_p)) if col_title_p else None
                area = _safe_str(rowp.get(col_area_p)) if col_area_p else None

                master.append(
                    dict(
                        source_sheet=sheet_name,
                        day=cur_day,
                        date=DATE_MAP[cur_day].isoformat(),
                        room="æµ·å ±",
                        location="æµ·å ±å€",
                        code=v0.strip(),
                        session=area,
                        title=title,
                        speaker=author,
                        affiliation=None,
                        start=start,
                        end=end,
                        start_dt=dt.datetime.combine(DATE_MAP[cur_day], t_start),
                        end_dt=dt.datetime.combine(DATE_MAP[cur_day], t_end),
                        kind="poster",
                    )
                )
            continue

        # ---- ä¸€èˆ¬åˆ†æœƒå ´ ----
        df = df0.copy()

        def _infer_default_day_from_sheet(sheet: str, df_: pd.DataFrame) -> Optional[str]:
            if "D1" in sheet:
                return "D1"
            if "D2" in sheet:
                return "D2"
            try:
                c0 = str(df_.columns[0])
                if "D1" in c0:
                    return "D1"
                if "D2" in c0:
                    return "D2"
            except Exception:
                pass
            return None

        def _promote_header_row_if_needed(df_: pd.DataFrame) -> pd.DataFrame:
            cols_ = [str(c) for c in df_.columns]
            if _find_col(cols_, ["æ™‚é–“"]):
                return df_
            header_idx: Optional[int] = None
            for i in range(min(len(df_), 30)):
                row_vals = [str(x).strip() for x in df_.iloc[i].tolist()]
                if any(v == "æ™‚é–“" or ("æ™‚é–“" in v and len(v) <= 6) for v in row_vals):
                    header_idx = i
                    break
            if header_idx is None:
                return df_
            new_cols = [str(x).strip() for x in df_.iloc[header_idx].tolist()]
            df2 = df_.iloc[header_idx + 1 :].copy()
            df2.columns = new_cols
            return df2

        default_day = _infer_default_day_from_sheet(sheet_name, df)
        df = _promote_header_row_if_needed(df)

        cols = [str(c) for c in df.columns]
        col_time = _find_col(cols, ["æ™‚é–“"])
        col_code = _find_col(cols, ["ç·¨è™Ÿ"])
        col_report = _find_col(cols, ["å ±å‘Šæ™‚é–“"])
        col_speaker = _find_col(cols, ["ä½œè€…å§“å", "è¬›è€…", "ä¸»æŒäºº"])
        col_aff = _find_col(cols, ["è¬›è€…å–®ä½", "å–®ä½"])

        title_candidates = [
            "æŠ•ç¨¿é¡Œç›®", "æ¼”è¬›ä¸»é¡Œ", "ä¸»é¡Œé ˜åŸŸ", "é¡Œç›®", "è¬›é¡Œ", "å ±å‘Šé¡Œç›®", "é¡Œå",
            "Title", "TITLE", "Topic", "TOPIC", "Presentation Title",
        ]
        col_title = _find_col(cols, title_candidates)

        cur_day: Optional[str] = default_day
        current_session_time: Optional[str] = None

        for _, row in df.iterrows():
            first = row.iloc[0]

            if isinstance(first, str) and re.search(r"/D[12]\s*$", first.strip()):
                cur_day = first.strip().split("/")[-1]
                current_session_time = None
                continue

            if col_time and isinstance(row.get(col_time), str):
                tr_block = _parse_time_range(row.get(col_time))
                if tr_block:
                    current_session_time = str(row.get(col_time)).strip()

            if not cur_day:
                continue

            tr: Optional[Tuple[str, str]] = None
            if col_report and isinstance(row.get(col_report), str):
                tr = _parse_time_range(row.get(col_report))
            if tr is None and current_session_time:
                tr = _parse_time_range(current_session_time)
            if tr is None and col_time and isinstance(row.get(col_time), str):
                tr = _parse_time_range(row.get(col_time))
            if tr is None:
                continue

            start, end = tr
            t_start = _parse_time_str(start)
            t_end = _parse_time_str(end)
            if t_start is None or t_end is None:
                continue

            code = _safe_str(row.get(col_code)) if col_code else None
            speaker = _safe_str(row.get(col_speaker)) if col_speaker else None
            aff = _safe_str(row.get(col_aff)) if col_aff else None

            title = _extract_title_with_span(row, cols, col_title, TITLE_SPAN_RIGHT)
            if not title:
                title = _fallback_title_from_row(row)

            if title in ("æŠ•ç¨¿é¡Œç›®", "æ¼”è¬›ä¸»é¡Œ", "ä¸»é¡Œé ˜åŸŸ", "é¡Œç›®", "è¬›é¡Œ") and (speaker is None) and (code is None):
                continue
            if (not title) and (not speaker) and (not code):
                continue
            if cur_day not in DATE_MAP:
                continue

            master.append(
                dict(
                    source_sheet=sheet_name,
                    day=cur_day,
                    date=DATE_MAP[cur_day].isoformat(),
                    room=sheet_name,
                    location=sheet_name,
                    code=code,
                    session=None,
                    title=title,
                    speaker=speaker,
                    affiliation=aff,
                    start=start,
                    end=end,
                    start_dt=dt.datetime.combine(DATE_MAP[cur_day], t_start),
                    end_dt=dt.datetime.combine(DATE_MAP[cur_day], t_end),
                    kind="room_detail",
                )
            )

    mdf = pd.DataFrame(master)
    if len(mdf) == 0:
        mdf = pd.DataFrame(columns=[
            "source_sheet","day","date","room","location","code","session","title",
            "speaker","affiliation","start","end","start_dt","end_dt","kind",
        ])

    mdf = mdf.drop_duplicates(subset=["date", "room", "start", "end", "code", "title", "speaker"], keep="first")
    mdf = mdf.sort_values(["start_dt", "room", "code"], na_position="last").reset_index(drop=True)

    mdf["display_date"] = mdf["date"].map(
        lambda s: "D1 (2026-01-26)" if s == "2026-01-26" else ("D2 (2026-01-27)" if s == "2026-01-27" else str(s))
    )
    mdf["time"] = mdf["start"].astype(str) + "â€“" + mdf["end"].astype(str)
    mdf["who"] = mdf["speaker"].fillna("")
    mdf["where"] = mdf["location"].fillna(mdf["room"])
    mdf["what"] = mdf["title"].fillna("")
    mdf["key"] = (
        mdf["date"].astype(str)
        + "|" + mdf["room"].astype(str)
        + "|" + mdf["start"].astype(str)
        + "|" + mdf["end"].astype(str)
        + "|" + mdf["code"].fillna("").astype(str)
        + "|" + mdf["title"].fillna("").astype(str)
    )
    return mdf


def _match_query(text: str, q: str) -> bool:
    tokens = [t.strip() for t in re.split(r"\s+", q) if t.strip()]
    text_low = text.lower()
    return all(t.lower() in text_low for t in tokens)


def filter_events(df: pd.DataFrame, query: str, days: List[str], rooms: List[str], include_main: bool) -> pd.DataFrame:
    out = df.copy()
    if not include_main:
        out = out[out["kind"] != "main_schedule"]
    if days:
        out = out[out["day"].isin(days)]
    if rooms:
        out = out[out["room"].isin(rooms)]

    if query.strip():
        q = query.strip()
        blob = (
            out["code"].fillna("") + " "
            + out["title"].fillna("") + " "
            + out["speaker"].fillna("") + " "
            + out["affiliation"].fillna("") + " "
            + out["room"].fillna("") + " "
            + out["source_sheet"].fillna("") + " "
            + out["session"].fillna("")
        )
        out = out[blob.map(lambda s: _match_query(s, q))]

    return out.sort_values(["start_dt", "room", "code"], na_position="last").reset_index(drop=True)


def events_from_selected(df_all: pd.DataFrame, selected_keys: set) -> pd.DataFrame:
    out = df_all[df_all["key"].isin(selected_keys)].copy()
    return out.sort_values(["start_dt", "room", "code"], na_position="last").reset_index(drop=True)


def add_conflict_flags(selected_df: pd.DataFrame) -> pd.DataFrame:
    """
    åŒæ—¥æ™‚é–“é‡ç–Š => conflict=Trueã€‚
    ä½†ï¼škind == 'poster' çš„äº‹ä»¶ä¸åƒèˆ‡è¡çªåµæ¸¬ï¼ˆä¹Ÿä¸æœƒè¢«æ¨™ç´…ï¼‰ã€‚
    """
    if selected_df is None or len(selected_df) == 0:
        return selected_df

    df = selected_df.copy()
    df["conflict"] = False

    # åªæ‹¿ã€Œéæµ·å ±ã€ä¾†åˆ¤å®šè¡çª
    non_poster = df[df["kind"] != "poster"].copy()
    if len(non_poster) == 0:
        return df

    for day in non_poster["day"].dropna().unique().tolist():
        sub = non_poster[non_poster["day"] == day].sort_values(["start_dt", "end_dt"]).copy()
        if len(sub) <= 1:
            continue

        active_end = None
        active_idx = None

        for idx, r in sub.iterrows():
            s = r["start_dt"]
            e = r["end_dt"]

            if active_end is None:
                active_end = e
                active_idx = idx
                continue

            if s < active_end:
                df.loc[idx, "conflict"] = True
                if active_idx is not None:
                    df.loc[active_idx, "conflict"] = True
                if e > active_end:
                    active_end = e
                    active_idx = idx
            else:
                active_end = e
                active_idx = idx

    return df


def mark_conflict_with_selected(candidates: pd.DataFrame, selected: pd.DataFrame) -> pd.DataFrame:
    """
    æœå°‹çµæœé è­¦ï¼šcandidate æ˜¯å¦èˆ‡å·²é¸ï¼ˆéæµ·å ±ï¼‰é‡ç–Šã€‚
    è¦å‰‡ï¼šå€™é¸æœ¬èº«è‹¥æ˜¯æµ·å ±(kind=poster) => ä¸€å¾‹ä¸æ¨™âš ï¸ï¼ˆä½¿ç”¨è€…éœ€æ±‚ï¼‰ã€‚
          å·²é¸ä¸­è‹¥æ˜¯æµ·å ±(kind=poster) => ä¸æ‹¿ä¾†åšè¡çªåŸºæº–ã€‚
    """
    out = candidates.copy()
    out["conflict_with_selected"] = False

    if out is None or len(out) == 0 or selected is None or len(selected) == 0:
        return out

    # å·²é¸è¡çªåŸºæº–ï¼šåªå–éæµ·å ±
    sel_basis = selected[selected["kind"] != "poster"].copy()
    if len(sel_basis) == 0:
        return out

    sel_by_day: Dict[str, List[Tuple[dt.datetime, dt.datetime, str]]] = {}
    for _, r in sel_basis.iterrows():
        day = str(r.get("day", ""))
        sdt = r.get("start_dt")
        edt = r.get("end_dt")
        key = str(r.get("key", ""))
        if not day or pd.isna(sdt) or pd.isna(edt):
            continue
        sel_by_day.setdefault(day, []).append((sdt, edt, key))

    for i, r in out.iterrows():
        # å€™é¸è‹¥ç‚ºæµ·å ±ï¼šä¸æ¨™è¡çª
        if str(r.get("kind", "")) == "poster":
            continue

        day = str(r.get("day", ""))
        sdt = r.get("start_dt")
        edt = r.get("end_dt")
        key = str(r.get("key", ""))
        if not day or pd.isna(sdt) or pd.isna(edt):
            continue

        intervals = sel_by_day.get(day, [])
        conflict = False
        for ss, ee, skey in intervals:
            if skey == key:
                continue
            if sdt < ee and ss < edt:
                conflict = True
                break
        out.loc[i, "conflict_with_selected"] = conflict

    return out


def df_for_picker(df: pd.DataFrame, selected_keys: set, show_conflict_with_selected: bool = True) -> pd.DataFrame:
    cols = ["key", "display_date", "time", "room", "code", "title", "speaker", "session", "affiliation", "where"]
    if "conflict_with_selected" in df.columns and show_conflict_with_selected:
        cols.insert(1, "conflict_with_selected")

    show = df[cols].copy()
    show.insert(0, "é¸å–", show["key"].map(lambda k: k in selected_keys))

    if "conflict_with_selected" in show.columns:
        show["conflict_with_selected"] = show["conflict_with_selected"].map(lambda x: "âš ï¸" if bool(x) else "")

    show = show.drop(columns=["key"])
    show = show.rename(
        columns={
            "conflict_with_selected": "è¡çª",
            "display_date": "æ—¥æœŸ",
            "time": "æ™‚é–“",
            "room": "æ•™å®¤/åˆ†æœƒå ´",
            "code": "ç·¨è™Ÿ",
            "title": "æŠ•ç¨¿é¡Œç›®/æ¼”è¬›ä¸»é¡Œ",
            "speaker": "ä½œè€…/è¬›è€…/ä¸»æŒ",
            "session": "ä¸»é¡Œé ˜åŸŸ",
            "affiliation": "å–®ä½",
            "where": "åœ°é»",
        }
    )
    return show


def build_ics(events: pd.DataFrame, cal_name: str = "Animal Behavior Workshop 2026") -> str:
    def fmt_dt(d: dt.datetime) -> str:
        return d.strftime("%Y%m%dT%H%M%S")

    def ics_escape(s: str) -> str:
        if s is None:
            return ""
        s = str(s)
        s = s.replace("\\", "\\\\")
        s = s.replace("\n", "\\n")
        s = s.replace(",", "\\,")
        s = s.replace(";", "\\;")
        return s

    lines = [
        "BEGIN:VCALENDAR",
        "VERSION:2.0",
        "PRODID:-//Yuju//ABW2026//EN",
        f"X-WR-CALNAME:{ics_escape(cal_name)}",
        "CALSCALE:GREGORIAN",
    ]

    for _, r in events.iterrows():
        uid = re.sub(r"[^A-Za-z0-9]", "", str(r.get("key", "")))[:40] + "@abw2026"

        kind = (r.get("kind") or "").strip()
        code = (r.get("code") or "").strip() if r.get("code") else ""
        title = (r.get("title") or "").strip() if r.get("title") else ""
        speaker = (r.get("speaker") or "").strip() if r.get("speaker") else ""
        room = (r.get("where") or r.get("room") or "").strip()
        affiliation = (r.get("affiliation") or "").strip() if r.get("affiliation") else ""
        area = (r.get("session") or "").strip() if r.get("session") else ""

        if code and title:
            summary = f"{code}ï½œ{title}"
        else:
            summary = title or code or ("Poster" if kind == "poster" else "Event")

        desc_parts = []
        if kind == "poster" and area:
            desc_parts.append(f"ä¸»é¡Œé ˜åŸŸ: {area}")
        if code:
            desc_parts.append(f"Code: {code}")
        if speaker:
            desc_parts.append(f"Speaker/Author: {speaker}")
        if affiliation:
            desc_parts.append(f"Affiliation: {affiliation}")
        if room:
            desc_parts.append(f"Room: {room}")
        description = "\\n".join(desc_parts) if desc_parts else ""

        lines.extend(
            [
                "BEGIN:VEVENT",
                f"UID:{ics_escape(uid)}",
                f"DTSTART:{fmt_dt(r['start_dt'])}",
                f"DTEND:{fmt_dt(r['end_dt'])}",
                f"SUMMARY:{ics_escape(summary)}",
                f"LOCATION:{ics_escape(room)}",
                f"DESCRIPTION:{ics_escape(description)}",
                "END:VEVENT",
            ]
        )

    lines.append("END:VCALENDAR")
    return "\n".join(lines)


# ----------------------------
# UI
# ----------------------------

st.set_page_config(page_title=APP_TITLE, layout="wide")
st.title(APP_TITLE)

with st.sidebar:
    st.markdown("### è¼¸å…¥è­°ç¨‹æª”æ¡ˆ")
    uploaded = st.file_uploader("ä¸Šå‚³ Excelï¼ˆ.xlsxï¼‰", type=["xlsx"])
    use_default = st.checkbox("ä½¿ç”¨é è¨­æª”æ¡ˆè·¯å¾‘ï¼ˆå·²æ›è¼‰ï¼‰", value=(uploaded is None))
    st.caption("é è¨­æª”æ¡ˆï¼š" + DEFAULT_EXCEL_PATH)

    st.markdown("---")
    st.markdown("### æœå°‹èˆ‡ç¯©é¸")
    query = st.text_input("é—œéµå­—ï¼ˆå¯è¼¸å…¥å¤šå€‹è©ï¼Œç©ºæ ¼=ANDï¼‰", value="")
    include_main = st.checkbox("åŒ…å«ã€å¤§æœƒè­°ç¨‹ã€çš„ä¸»è¡¨äº‹ä»¶ï¼ˆå ±åˆ°/é–‹å¹•ç­‰ï¼‰", value=True)

file_bytes: Optional[bytes] = None
if uploaded is not None:
    file_bytes = uploaded.getvalue()
elif use_default:
    try:
        with open(DEFAULT_EXCEL_PATH, "rb") as f:
            file_bytes = f.read()
    except Exception as e:
        st.error(f"è®€å–é è¨­æª”æ¡ˆå¤±æ•—ï¼š{e}")

if not file_bytes:
    st.info("è«‹åœ¨å·¦å´ä¸Šå‚³ Excel æª”ï¼Œæˆ–å‹¾é¸ä½¿ç”¨é è¨­æª”æ¡ˆã€‚")
    st.stop()

sheets = load_excel_all_sheets(file_bytes)
df_all = build_master_df(sheets)

with st.sidebar:
    days = st.multiselect("æ—¥æœŸ", options=["D1", "D2"], default=["D1", "D2"])
    rooms = st.multiselect("æ•™å®¤/åˆ†æœƒå ´", options=sorted(df_all["room"].unique().tolist()), default=[])

if "selected_keys" not in st.session_state:
    st.session_state["selected_keys"] = set()

selected_df = events_from_selected(df_all, st.session_state["selected_keys"])
selected_df = add_conflict_flags(selected_df)

df_hit = filter_events(df_all, query=query, days=days, rooms=rooms, include_main=include_main)
df_hit2 = mark_conflict_with_selected(df_hit, selected_df)

# ----------------------------
# 1) æœå°‹çµæœ
# ----------------------------
st.subheader("1) æœå°‹çµæœï¼ˆå‹¾é¸åŠ å…¥å€‹äººåŒ–è¡Œäº‹æ›†ï¼‰")
st.caption(f"ç¬¦åˆç­†æ•¸ï¼š{len(df_hit2)}ï¼ˆâš ï¸ è¡¨ç¤ºæœƒèˆ‡ä½ å·²é¸çš„ã€éæµ·å ±ã€è¡Œç¨‹æ™‚é–“é‡ç–Šï¼›æµ·å ±ä¸æ¨™è¡çªï¼‰")

picker_df = df_for_picker(df_hit2, st.session_state["selected_keys"], show_conflict_with_selected=True)

edited = st.data_editor(
    picker_df,
    use_container_width=True,
    hide_index=True,
    column_config={
        "é¸å–": st.column_config.CheckboxColumn("é¸å–", help="å‹¾é¸åŠ å…¥å€‹äººåŒ–è¡Œäº‹æ›†"),
        "è¡çª": st.column_config.TextColumn("è¡çª", width="small", help="âš ï¸ è¡¨ç¤ºæœƒèˆ‡å·²é¸ï¼ˆéæµ·å ±ï¼‰è¡Œç¨‹æ’æœŸï¼›æµ·å ±ä¸æ¨™"),
        "æŠ•ç¨¿é¡Œç›®/æ¼”è¬›ä¸»é¡Œ": st.column_config.TextColumn(width="large"),
        "ä½œè€…/è¬›è€…/ä¸»æŒ": st.column_config.TextColumn(width="medium"),
        "ä¸»é¡Œé ˜åŸŸ": st.column_config.TextColumn(width="medium"),
        "å–®ä½": st.column_config.TextColumn(width="medium"),
    },
    disabled=[
        "è¡çª", "æ—¥æœŸ", "æ™‚é–“", "æ•™å®¤/åˆ†æœƒå ´", "ç·¨è™Ÿ",
        "æŠ•ç¨¿é¡Œç›®/æ¼”è¬›ä¸»é¡Œ", "ä½œè€…/è¬›è€…/ä¸»æŒ", "ä¸»é¡Œé ˜åŸŸ", "å–®ä½", "åœ°é»",
    ],
    key="editor_results",
)

hit_keys = df_hit2["key"].tolist()
new_selected = set(st.session_state["selected_keys"])
for i, row in edited.iterrows():
    k = hit_keys[i]
    if bool(row["é¸å–"]):
        new_selected.add(k)
    else:
        new_selected.discard(k)
st.session_state["selected_keys"] = new_selected

c1, c2, c3 = st.columns([0.22, 0.22, 0.56])
with c1:
    if st.button("å…¨é¸ï¼ˆæœ¬é ï¼‰"):
        st.session_state["selected_keys"] = set(st.session_state["selected_keys"]).union(set(hit_keys))
        st.rerun()
with c2:
    if st.button("å…¨å–æ¶ˆ"):
        st.session_state["selected_keys"] = set()
        st.rerun()
with c3:
    st.caption("æç¤ºï¼šä½ å¯ä»¥å…ˆç”¨é—œéµå­—æˆ–æ•™å®¤ç¯©é¸ç¸®å°ç¯„åœï¼Œå†å…¨é¸ã€‚")

# ----------------------------
# 2) å€‹äººåŒ–è¡Œäº‹æ›†
# ----------------------------
st.markdown("---")
st.subheader("2) å€‹äººåŒ–è¡Œäº‹æ›†ï¼ˆå…©å¤©ï¼‰")

selected_df = events_from_selected(df_all, st.session_state["selected_keys"])
selected_df = add_conflict_flags(selected_df)

d1_n = int((selected_df["day"] == "D1").sum()) if len(selected_df) else 0
d2_n = int((selected_df["day"] == "D2").sum()) if len(selected_df) else 0
conf_n = int(selected_df["conflict"].sum()) if len(selected_df) and "conflict" in selected_df.columns else 0

m1, m2, m3 = st.columns(3)
m1.metric("D1 å·²é¸", d1_n)
m2.metric("D2 å·²é¸", d2_n)
m3.metric("è¡çªå ´æ¬¡ï¼ˆä¸å«æµ·å ±ï¼‰", conf_n)

if len(selected_df) == 0:
    st.info("å°šæœªé¸å–ä»»ä½•è­°ç¨‹ã€‚")
else:
    def _style_conflicts(df_view: pd.DataFrame) -> pd.io.formats.style.Styler:
        def row_style(r):
            if str(r.get("è¡çª", "")).strip() == "âš ï¸":
                return ["background-color: #ffe5e5; font-weight: 600;" for _ in r]
            return ["" for _ in r]
        return df_view.style.apply(row_style, axis=1)

    for day, label in [("D1", "D1ï½œ2026-01-26"), ("D2", "D2ï½œ2026-01-27")]:
        sub = selected_df[selected_df["day"] == day].copy()
        expand_default = bool((sub["conflict"].sum() > 0)) if len(sub) else False

        with st.expander(f"{label}ï¼ˆ{len(sub)} å ´ï¼‰", expanded=expand_default):
            if len(sub) == 0:
                st.caption("ï¼ˆæ­¤æ—¥å°šæœªé¸å–ï¼‰")
                continue

            view = sub[["start", "end", "room", "code", "title", "speaker", "session", "conflict", "kind"]].copy()
            view = view.rename(
                columns={
                    "start": "é–‹å§‹",
                    "end": "çµæŸ",
                    "room": "æ•™å®¤/é¡åˆ¥",
                    "code": "ç·¨è™Ÿ",
                    "title": "ä¸»é¡Œ",
                    "speaker": "è¬›è€…/ä½œè€…",
                    "session": "ä¸»é¡Œé ˜åŸŸ",
                    "conflict": "è¡çª",
                    "kind": "é¡å‹",
                }
            )
            view["è¡çª"] = view.apply(lambda r: ("âš ï¸" if bool(r["è¡çª"]) else ""), axis=1)

            st.dataframe(_style_conflicts(view.drop(columns=["é¡å‹"])), use_container_width=True, hide_index=True)

    ics_text = build_ics(selected_df)
    st.download_button(
        "ä¸‹è¼‰ .ics è¡Œäº‹æ›†æª”ï¼ˆå¯åŒ¯å…¥ Google/Apple Calendarï¼‰",
        data=ics_text.encode("utf-8"),
        file_name="animal_behavior_workshop_2026_selected.ics",
        mime="text/calendar",
    )

# ----------------------------
# 3) Raw sheets
# ----------------------------
st.markdown("---")
st.subheader("3) å¤§æœƒè­°ç¨‹ï¼ˆExcel åŸå§‹åˆ†é ï¼‰")
st.caption("ä¸‹æ–¹ç›´æ¥å‘ˆç¾ Excel æ¯å€‹åˆ†é å…§å®¹ï¼Œä¾¿æ–¼æ ¸å°ã€‚")

tab_names = list(sheets.keys())
tabs = st.tabs(tab_names)
for name, tab in zip(tab_names, tabs):
    with tab:
        st.dataframe(sheets[name], use_container_width=True, hide_index=True)
